<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ§‹é€ ã®å¯è¦–åŒ–</title>
  <script src="https://cdn.jsdelivr.net/npm/graphology@0.25.1/dist/graphology.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@2.4.0/build/sigma.min.js"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background: #ffffff;
      margin: 0;
      padding: 1em;
      text-align: center;
      color: #333;
    }
    #overview-graph {
      position: relative;
      width: 100%;
      height: 90vh;
      border-top: 1px solid #ccc;
    }
    #info {
      font-family: monospace;
      font-size: 0.95em;
      padding: 10px;
      background: #f7f7f7;
      border-top: 1px solid #ccc;
    }
    #annotations {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      pointer-events: none;
      display: flex;
      justify-content: space-around;
      padding-top: 5px;
    }
    #annotations span {
      font-weight: bold;
      font-size: 14px;
      color: #444;
    }
  </style>
</head>
<body>
  <h2>ğŸ§  ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ§‹é€ </h2>
  <div id="overview-graph">
    <div id="annotations"></div>
  </div>
  <div id="info">ãƒãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨æ´»æ€§å€¤ã¨æ¥ç¶šãŒãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã¾ã™</div>

  <script>
    window.addEventListener("message", (event) => {
      const { nodes, edges, prediction } = event.data;

      const Graph = graphology.Graph;
      const graph = new Graph();

      // å±¤ç•ªå·ã”ã¨ã«åˆ†é¡
      const layerMap = {};
      nodes.forEach((n) => {
        const match = n.id.match(/^L(\d+)N/);
        if (!match) return;
        const layer = parseInt(match[1]);
        if (!layerMap[layer]) layerMap[layer] = [];
        layerMap[layer].push(n);
      });

      const sortedLayers = Object.keys(layerMap).map(Number).sort((a, b) => a - b);

      // ãƒãƒ¼ãƒ‰ç™»éŒ²ï¼ˆå±¤ã«å¿œã˜ãŸè‰²åˆ†ã‘ï¼‰
      nodes.forEach((n) => {
        const layer = parseInt(n.id.match(/^L(\d+)N/)[1]);
        const value = Math.max(0, Math.min(1, n.value));
        const size = 1 + 4 * value;

        let color = "#aaaaaa";
        if (layer === sortedLayers[0]) color = "#888"; // å…¥åŠ›å±¤
        else if (layer === sortedLayers[sortedLayers.length - 1]) color = "#28a745"; // å‡ºåŠ›å±¤
        else color = "#1e90ff"; // éš ã‚Œå±¤

        graph.addNode(n.id, {
          label: n.label,
          size,
          color,
          x: n.x,
          y: n.y,
          value: n.value,
        });
      });

      edges.forEach((e) => {
        graph.addEdge(e.source, e.target, {
          weight: e.weight,
          size: Math.max(1, Math.abs(e.weight) * 2),
          color: e.weight >= 0 ? "#0044cc" : "#cc0000",
        });
      });

      const container = document.getElementById("overview-graph");
      const renderer = new Sigma(graph, container);

      // ã‚«ãƒ¡ãƒ©è‡ªå‹•èª¿æ•´
      const bounds = graph.extent();
      const centerX = (bounds[0][0] + bounds[1][0]) / 2;
      const centerY = (bounds[0][1] + bounds[1][1]) / 2;
      const width = bounds[1][0] - bounds[0][0];
      const height = bounds[1][1] - bounds[0][1];
      const zoom = Math.min(
        container.clientWidth / (width * 100),
        container.clientHeight / (height * 100)
      );
      renderer.getCamera().setState({ x: centerX, y: centerY, zoom });

      // å±¤æ³¨é‡ˆã®è¡¨ç¤º
      const ann = document.getElementById("annotations");
      ann.innerHTML = "";
      sortedLayers.forEach((layer, i) => {
        const label =
          i === 0
            ? "å…¥åŠ›å±¤"
            : i === sortedLayers.length - 1
            ? `å‡ºåŠ›å±¤ï¼ˆäºˆæ¸¬: ${prediction ?? "?"}ï¼‰`
            : `éš ã‚Œå±¤ L${layer}`;
        const span = document.createElement("span");
        span.textContent = label;
        ann.appendChild(span);
      });

      // ãƒãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯ â†’ æ´»æ€§å€¤ï¼†ã‚¨ãƒƒã‚¸å¼·èª¿
      renderer.on("clickNode", ({ node }) => {
        const attr = graph.getNodeAttributes(node);
        document.getElementById("info").textContent = `ğŸ” ${attr.label} ã®æ´»æ€§å€¤ = ${attr.value.toFixed(4)}`;
        graph.forEachEdge((eid, attrs, src, tgt) => {
          const active = src === node || tgt === node;
          graph.setEdgeAttribute(eid, "color", active ? "#ffa500" : "#ccc");
          graph.setEdgeAttribute(eid, "size", active ? 3 : 1);
        });
        renderer.refresh();
      });

      // èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ â†’ ãƒªã‚»ãƒƒãƒˆ
      renderer.on("clickStage", () => {
        document.getElementById("info").textContent =
          "ãƒãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨æ´»æ€§å€¤ã¨æ¥ç¶šãŒãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã¾ã™";
        graph.forEachEdge((eid) => {
          graph.setEdgeAttribute(eid, "color", "#ccc");
          graph.setEdgeAttribute(eid, "size", 1);
        });
        renderer.refresh();
      });
    });
  </script>
</body>
</html>